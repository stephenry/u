## ==================================================================== ##
## Copyright (c) 2025, Stephen Henry
## All rights reserved.
##
## Redistribution and use in source and binary forms, with or without
## modification, are permitted provided that the following conditions
## are met:
##
## * Redistributions of source code must retain the above copyright
##   notice, this list of conditions and the following disclaimer.
##
## * Redistributions in binary form must reproduce the above copyright
##   notice, this list of conditions and the following disclaimer in
##   the documentation and/or other materials provided with the
##   distribution.
##
## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
## "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
## LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
## FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
## COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
## HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
## STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
## OF THE POSSIBILITY OF SUCH DAMAGE.
## ==================================================================== ##

import sys
import pathlib

sys.path.extend([
    '@CMAKE_BINARY_DIR@/py',
    '@CMAKE_SOURCE_DIR@/syn',
])

# Root of all RTL source files
RTL_ROOT = '@CMAKE_SOURCE_DIR@/rtl'

SYN_ROOT = '@CMAKE_SOURCE_DIR@/syn'

TOP_LEVEL_TEMPLATE = pathlib.Path('@CMAKE_CURRENT_SOURCE_DIR@/top.sv.tmpl')

# Compile project sources

projects = dict()

# 'C'-Project
projects['c'] = [
    'c_v_cell.sv',
    'c_v.sv',
    'c.sv',
]

# 'E'-Project
projects['e'] = [
    'e_is_1hot.sv',
    'e.sv',
]

# 'O'-Project
projects['o'] = [
    'o.sv',
]

# 'P'-Project
projects['p'] = [
    'p_is_1hot.sv',
    'p.sv',
]

# 'U'-Project
projects['u'] = [
    'u_mask.sv',
    'u.sv',
]



# Fix up paths
for k, v in projects.items():
    projects[k] = [f"{RTL_ROOT}/{k}/{f}" for f in v]


args = {
    # W(idth) Parameter sweep.
    'w_sweep': [4, 8, 16, 32, 64, 128],

    # Clock frequency sweep.
    'frequency_sweep': range(40, 420, 20),

    # Projects to evaluate
    'projects': projects,

    # RTL include paths
    'include_paths': [
        RTL_ROOT,
    ],

    # RTL Top-level template
    'top_level_template': TOP_LEVEL_TEMPLATE,

    'echo': False,
}

from syn import run_synthesis_flow
results = run_synthesis_flow(**args)


def report_results(f):
    # Title
    title = [ 'Project' ]
    title.extend([ f'W={w}' for w in args['w_sweep'] ])
    title.append('Notes')
    f.write(f"| {' | '.join(title)} |\n")

    # Justification
    justify = [ ':---:' for _ in title ]
    f.write(f"| {' | '.join(justify)} |\n")

    project_to_desc_map = {
        'c': 'serial',
        'e': 'edge',
        'o': 'optimal',
        'p': 'inc',
        'u': 'mask',
    }

    project_to_notes_map = {
        'c': 'Linear, worst',
        'e': 'Sub-Linear (best overall?)',
        'o': 'Expected Winner',
        'p': 'Good Area, Timing Risk',
        'u': 'High area growth',
    }

    for project, s1 in results.items():
        f.write(f'| {project} ({project_to_desc_map.get(project, "")}) ')
        for w, r in s1.items():
            f.write(f'| ({r})')
        f.write(f'| {project_to_notes_map.get(project, "")} ')
        f.write('|\n')

 # Emit Markdown Table of Results
with open(f"{SYN_ROOT}/syn_results.md", 'w') as f:
    report_results(f)

 # Graph Results

import matplotlib.pyplot as plt

# Data from your table (area in µm²)
widths = args['w_sweep']

area = {}
frequency = {}
for project, s1 in results.items():
    area[project] = []
    frequency[project] = []
    for w, r in s1.items():
        area[project].append(r.combinatorial_area())
        frequency[project].append(r.f_max())

fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), sharex=True)

for label, areas in area.items():
    ax1.plot(widths, areas, marker='o', label=label)
ax1.set_ylabel('Cell Area (µm²)')
ax1.grid(True, ls="--", alpha=0.7)
ax1.legend(ncol=2)

for label, f_maxs in frequency.items():
    ax2.plot(widths, f_maxs, marker='s', label=label)
ax2.set_xlabel('Width (W)')
ax2.set_ylabel('Max Frequency (MHz)')
ax2.grid(True, ls="--", alpha=0.7)
ax2.set_xscale('log', base=2)
ax2.set_xticks(widths)
ax2.set_xticklabels(widths)

plt.suptitle('PPA Comparison vs. Vector Width (Sky130 HD, Slow Corner)')
plt.tight_layout()
plt.savefig('ppa_separate.png', dpi=300)
import shutil
shutil.move('ppa_separate.png', SYN_ROOT + '/ppa_separate.png')
